Comments

    (* comment *)
    (* (*nested*) comment *)

Infix operators

    Notation left 50 (+) := plus.
    Notation left 40 (*) := multiply.
    Notation right 30 (^) := power.

Prefix operators

    Notation prefix (~) := negate.

Functions

    Definition fact (n : nat) : nat :=
        case n of
        | 0 => 1
        | S k => n * fact(k)
        end.

Procedures

    (* simple hello world program
       [Procedure] is basically a shorthand for [Definition] that returns [partial]
       thus type of [main] is [partial unit] *)
    Procedure main : unit := print "Hello world!".

    (* a completely imperative version of factorial calculation *)
    Procedure fact_imp (n : nat) : nat :=
        local result := ref 1 in
        local i := ref 1 in
        loop
            if (read i) `leb` n then
                write result ((read result) * (read i));
                write i ((read i) + 1)
            else
                return (read result)
            end
        end.

Axiom

    (* if you believe that your imperative code is referentially transparent and will terminate, you
       can use [trust] to extract the value from [partial] without any checks *)
    Definition fact_imp_trusted (n : nat) : nat := trust (fact_imp n).

    (* and if you believe that your imperative code is correct, you may introduce axioms to
       postulate its properties *)
    Axiom fact_imp_behaves_same_as_fact : forall {n : nat}, fact_imp_trusted n = fact n.

    (* widely accepted axiom of function extensionality *)
    Axiom funext : forall {A B : Type},
                   forall (f g : A -> B),
                   (forall x : A, f x = g x) ->
                   f = g.

    Definition fact_imp_is_fact : fact_imp_trusted = fact :=
        funext fact_imp_trusted fact fact_imp_behaves_same_as_fact.

A somewhat less trivial example

    (* factorials from 0 to 10 *)
    Procedure main : unit :=
        print "Hello, world!";
        local i := ref 0 in loop
            if negb (i `leb` 10) then
                print "fact " i " = " (fact (read i)) "\n";
                print "fact_imp " i " = " (fact_imp (read i)) "\n";
                print "fact_imp_trust " i " = " (fact_imp_trust (read i)) "\n";
                write i ((read i) + 1)
            else
                return
            end
        end.

Lambda

    Definition double_list (l : list nat) : list nat :=
        map (fun x : nat => x + x) l.

    Procedure for_each_list (l : list nat) (action : nat -> partial unit) : partial unit :=
        foreach (proc x : nat => action x) l.

Proofs (now via term construction)

    Definition add_assoc (a b c : nat) : a + b + c = a + (b + c) :=
        case a of
        | 0 => eq_refl
        | S a' => cong S (add_assoc a' b c)
        end.
