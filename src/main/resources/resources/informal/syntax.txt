Comments

    (* comment *)
    (* (*nested*) comment *)

Infix operators

    Notation left 50 (+) := plus.
    Notation left 40 (*) := multiply.
    Notation right 30 (^) := power.

Prefix operators

    Notation prefix (~) := negate.

Functions

    Definition fact (n : nat) : nat :=
        case n of
        | 0 => 1
        | S k => n * fact(k)
        end.

Procedures

    (* simple hello world program
       [Procedure] is basically a shorthand for [Definition] that returns [partial]
       thus type of [main] is [partial unit] *)
    Procedure main : unit := print "Hello world!".

    (* factorials from 0 to 10 *)
    Procedure main : unit :=
        print "Hello, world!";
        local i := ref 0 in loop
            if negb (i `leb` 10) then
                print (fact (read i));
                write i ((read i) + 1)
            else
                return
            end
        end.

Lambda

    Definition double_list (l : list nat) : list nat :=
        map (fun x : nat => x + x) l.

    Procedure for_each_list (l : list nat) (action : nat -> partial unit) : partial unit :=
        foreach (proc x : nat => action x) l.

Axiom

    (* currently using type-in-type, which is known vulnerable to Girard's paradox
       we'll switch to universe hierarchies later *)
    Axiom funext : forall {A B : *},
                   forall (f g : A -> B),
                   (forall x : A, f x = g x) ->
                   f = g.

    (* future *)
    Axiom funext : forall {l : Level},
                   forall {A B : Type l},
                   forall (f g : A -> B),
                   (forall x : A, f x = g x) ->
                   f = g.
